import torch
import torch.nn as nn
from torch.utils.data import DataLoader, TensorDataset
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Using device: {device}")

def load_data(file_path):
    df = pd.read_csv(file_path, index_col="Date", parse_dates=True)
    return df

def split_data(df, train_ratio=0.8, val_ratio=0.1):
    train_size = int(len(df) * train_ratio)
    val_size = int(len(df) * val_ratio)
    train_df = df.iloc[:train_size]
    val_df = df.iloc[train_size : train_size + val_size]
    test_df = df.iloc[train_size + val_size :]
    return train_df, val_df, test_df

def create_scaler(train_df):
    scaler = {}
    for col in train_df.columns:
        scaler[col] = {"min": train_df[col].min(), "max": train_df[col].max()}
    return scaler

def scale_data(data, scaler):
    scaled_data = data.copy()
    for col in data.columns:
        min_val = scaler[col]["min"]
        max_val = scaler[col]["max"]
        scaled_data[col] = (data[col] - min_val) / (max_val - min_val)
    return scaled_data

def create_multivariate_sequences(data, target_col, seq_length):
    xs, ys = [], []
    data_np = data.values
    target_idx = data.columns.get_loc(target_col)

    for i in range(len(data_np) - seq_length):
        x = data_np[i : i + seq_length]
        y = data_np[i + seq_length, target_idx]
        xs.append(x)
        ys.append(y)
    return np.array(xs), np.array(ys).reshape(-1, 1)


def create_data_loaders(X_train, y_train, X_val, y_val, batch_size):
    X_train = torch.from_numpy(X_train).float()
    y_train = torch.from_numpy(y_train).float()
    X_val = torch.from_numpy(X_val).float()
    y_val = torch.from_numpy(y_val).float()
    # TODO1
    return train_loader, val_loader

class SequenceModel(nn.Module):
    # TODO2

class EarlyStopping:
    def __init__(self, patience=10, verbose=False, delta=0, path="checkpoint.pt"):
        self.patience, self.verbose, self.delta, self.path = (
            patience,
            verbose,
            delta,
            path,
        )
        self.counter, self.best_score, self.early_stop, self.val_loss_min = (
            0,
            None,
            False,
            np.inf,
        )

    def __call__(self, val_loss, model):
        score = -val_loss
        if self.best_score is None:
            self.best_score = score
            self.save_checkpoint(val_loss, model)
        elif score < self.best_score + self.delta:
            self.counter += 1
            if self.verbose:
                print(f"EarlyStopping counter: {self.counter} out of {self.patience}")
            if self.counter >= self.patience:
                self.early_stop = True
        else:
            self.best_score = score
            self.save_checkpoint(val_loss, model)
            self.counter = 0

    def save_checkpoint(self, val_loss, model):
        if self.verbose:
            print(
                f"Validation loss decreased ({self.val_loss_min:.6f} --> {val_loss:.6f}). Saving model..."
            )
        torch.save(model.state_dict(), self.path)
        self.val_loss_min = val_loss


def train_model(
    model, train_loader, val_loader, device, num_epochs, learning_rate, patience=10
):
  TODO3

def inverse_scale_data(data, scaler, target_col):
    min_val = scaler[target_col]["min"]
    max_val = scaler[target_col]["max"]
    return data * (max_val - min_val) + min_val


def evaluate_and_visualize(
    model, X_test, y_test, test_df, scaler, target_column, seq_length, device
):
    model.eval()
    with torch.no_grad():
        test_outputs = model(X_test.to(device)).cpu().numpy()

    predicted_prices = inverse_scale_data(test_outputs, scaler, target_column)
    actual_prices = inverse_scale_data(y_test.numpy(), scaler, target_column)

    plt.figure(figsize=(15, 7))
    plt.title(f"Futures Gold Price Prediction (LSTM)")
    plt.plot(
        test_df.index[seq_length:], actual_prices, label="Actual Price", color="blue"
    )
    plt.plot(
        test_df.index[seq_length:],
        predicted_prices,
        label="Predicted Price",
        color="red",
        linestyle="--",
    )
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.grid(True)
    plt.show()

    return predicted_prices, actual_prices

# run
# TODO1